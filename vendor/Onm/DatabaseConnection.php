<?php
/**
 * Defines the Onm\DatabaseConnection class
 *
 * This file is part of the Onm package.
 *
 * (c)  OpenHost S.L. <developers@openhost.es>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @package  Onm
 **/
namespace Onm;

/**
* Wrapper for the AdoDB library for making it container compatible
*
* @package  Onm
*/
class DatabaseConnection
{
    /**
     * The database connection with write-actions support
     *
     * @var AdodbConnection
     **/
    public $masterConnection = null;

    /**
     * The read-only database connection
     *
     * @var AdodbConnection
     **/
    public $slaveConnections = array();

    /**
     * Whether to use replication
     * This property is autogenerated from the
     * connection params (if there are slave servers then this will be true)
     *
     * @var boolean
     **/
    private $useReplication = false;

    /**
     * The database server connection params
     *
     * @var array
     **/
    public $connectionParams = null;

    /**
     * Stores the query error
     *
     * @var string
     **/
    public $error = null;



    /**
     * Starts the database connection
     *
     * @param array $params an array containing the database server connection params
     *
     * @return DatabaseConnection the object
     **/
    public function __construct($params)
    {
        // Check if the connection params are valid
        if (!$this->isConfigurationValid($params)) {
            throw new \Exception('Database connection parameters not valid');
        };

        // Store connection params are valid
        $this->fullConnectionParams = $params;
        $this->defaultConnection    = $params['dbal']['default_connection'];
        $this->connectionParams     = $params['dbal']['connections'][$this->defaultConnection];
        $this->useReplication       = $this->configHasSlaves();

        // Set default params
        if (!array_key_exists('charset', $this->connectionParams)) {
            $this->connectionParams['charset'] = 'UTF8';
        }
    }

    /**
     * Checks if the given database configuration params are valid
     *  - Params is an array
     *  - Params has a dbal key
     *  - params[dbal] has a connections key hat is an array
     *  - params has a default_connection key that is a key inside the connections array
     *
     * @return boolean true if the given params are valid
     **/
    public function isConfigurationValid($params)
    {
        return (
            is_array($params)
            && array_key_exists('dbal', $params)
            && (array_key_exists('connections', $params['dbal']) && is_array($params['dbal']['connections']))
            && array_key_exists('default_connection', $params['dbal'])
            && array_key_exists($params['dbal']['default_connection'], $params['dbal']['connections'])
        );
    }

    /**
     * Returns true if the configuration has slave connection params
     *
     * @return boolean true if the configuration has slave connection params
     **/
    public function configHasSlaves()
    {
        return array_key_exists('slaves', $this->connectionParams);
    }

    /**
     * Returns the current configuration parameters
     *
     * @return array the database configuration parameters
     **/
    public function getCurrentDatabaseParams()
    {
        return $this->connectionParams;
    }

    /**
     * Redirects all the calls to the AdodbConnection instance
     *
     * @param string $method the method to call
     * @param array $params the list of parameters to pass to the method
     *
     * @return mixed the result of the method call
     **/
    public function __call($method, $params)
    {
        $connection = $this->getConnection($method, $params);

        $rs = call_user_func_array(array($connection, $method), $params);

        if ($rs === false) {
            $this->error = $connection->ErrorMsg();
        }

        return $rs;
    }

    public function selectDatabase($databaseName)
    {
        $this->connectionParams = $this->replaceKeyInArray(
            function ($key, $value, $databaseName) {
                if ($key == 'dbname' && !is_null($value)) {
                    $value = $databaseName;
                }
                return $value;
            },
            $this->connectionParams,
            $databaseName
        );

        $this->resetConnections();

        return $this;
    }

    /**
     * Deletes stablished connections
     *
     **/
    public function resetConnections()
    {
        $this->masterConnection = null;
        $this->slaveConnections = array();

        return $this;
    }

    private function replaceKeyInArray($callback, $array, $databaseName)
    {
        foreach ($array as $key => $value) {
            if (is_array($array[$key])) {
                $array[$key] = $this->replaceKeyInArray($callback, $array[$key], $databaseName);
            } else {
                $array[$key] = call_user_func($callback, $key, $array[$key], $databaseName);
            }
        }
        return $array;
    }

    public function initConnection($params)
    {
        if ($params['charset'] == 'UTF-8') {
            $params['charset'] = 'UTF8';
        }

        $connection = \ADONewConnection($params['driver']);

        // Not valid/supported driver
        if (!is_object($connection)) {
            return null;
        }

        $connection->Connect(
            $params['host'],
            $params['user'],
            $params['password'],
            $params['dbname']
        );

        // Failed connection
        if (!$connection->_connectionID) {
            return null;
        }

        $connection->SetFetchMode(ADODB_FETCH_ASSOC);
        $connection->bulkBind = true;

        // Commented for now as it crashes the
        // $connection->Execute("SET names '{$params['charset']}'");

        return $connection;
    }

    /**
     * Returns the proper connection whether is a read or a write query
     * given the SQL method to execute
     *
     * @param string $method The method to execute
     * @param array  $params The parameters of the call
     *
     * @return the database connection
     **/
    public function getConnection($method, $params)
    {
        $isReadOnlyQuery =  $this->isReadOnlyAction($method, $params);

        if ($this->useReplication
            && $isReadOnlyQuery
        ) {
            $connection = $this->getSlaveConnection();
        } else {
            $connection = $this->getMasterConnection();
        }

        return $connection;
    }

    /**
     * Returns true if the action will perform read only actoin
     *
     * @return void
     * @author
     **/
    public function isReadOnlyAction($method, $params)
    {
        return  (
                    $method !== 'StartTrans'
                    || $method !== 'CompleteTrans'
                    || $method !== 'FailTrans'
                    || $method !== 'HasFailedTrans'
                )
                && stripos($params[0], 'SELECT') !== false;
    }

    /**
     * Returns one slave database connection from the list of slave connections
     *
     * @return AdoDBConnection the master database connection
     **/
    public function getSlaveConnection()
    {
        // Initialize the slaves list is not defined
        if (count($this->slaveConnections) < 1) {
            // Little hack for avoid initialize the master connection if
            // it will not be used
            $this->slaveConnections[0] = null;

            // Do not initialize an slave connection if
            if (array_key_exists('slaves', $this->connectionParams)) {
                $slavesList = $this->connectionParams['slaves'];
                unset($this->connectionParams['slaves']);

                // Try to initialize a slave connection
                // from the list of slaves connection parameters
                $slaveConnection = null;
                do {

                    $randomSlaveIndex = array_rand($slavesList);
                    $slaveParams = $slavesList[$randomSlaveIndex];

                    $slaveParams = array_filter(
                        $slaveParams,
                        function ($item) {
                            return !is_null($item);
                        }
                    );
                    $slaveParams = array_merge($this->connectionParams, $slaveParams);

                    $slaveConnection = $this->initConnection($slaveParams);

                    unset($slavesList[$randomSlaveIndex]);
                } while (!is_object($slaveConnection) && !empty($slavesList));

                if (!is_null($slaveConnection)) {
                    $this->slaveConnections []= $slaveConnection;
                }
            }
        }

        $randomIndex = array_rand($this->slaveConnections);

        // If the above random key has selected the master collection initialize it
        if ($randomIndex == 0) {
            $this->slaveConnections[0]= $this->getMasterConnection();
        }

        return $this->slaveConnections[$randomIndex];
    }

    /**
     * Returns the master database connection
     *
     * @return AdoDBConnection the master database connection
     **/
    public function getMasterConnection()
    {
        // It the master collection is not initialized create it
        if (!is_object($this->masterConnection)) {
            $this->masterConnection = $this->initConnection($this->connectionParams);
        }

        return $this->masterConnection;
    }
}
