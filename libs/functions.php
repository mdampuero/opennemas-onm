<?php
/**
 * This file is part of the Onm package.
 *
 * (c)  OpenHost S.L. <developers@openhost.es>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
/**
 * This file stores shared function that could be used by the framework
 */

function underscore($name)
{
    return strtolower(preg_replace('/(?<=\\w)([A-Z])/', '_\\1', $name));
}

function classify($name)
{
    $parts = explode('_', $name);
    $parts = array_map(
        function ($token) {
            return ucfirst($token);
        },
        $parts
    );

    $className = implode('', $parts);

    return $className;
}

function tableize($name)
{
    return pluralize(underscore($name));
}

function pluralize($name)
{
    return strtolower($name) . 's';
}

function clearslash($string)
{
    $string = stripslashes($string);
    $string = str_replace("\\", '', $string);

    return stripslashes($string);
}

/**
 * Register in the log one event in the content
 *
 * @return void
 */
function logContentEvent($action = null, $content = null)
{
    $logger = getService('application.log');
    $msg    = "Action {$action} executed";

    if (!empty($content)) {
        $msg .= " at " . get_class($content) . " " . $content->content_type_name . " (ID:{$content->id})";
    }

    $logger->info($msg);
}

/**
 * Returns the autogenerated url given its name and a set of parameters
 *
 * @param string   $urlName the name of the url, i.e. admin_sytem_settings
 * @param array    $params additional params to generate the url
 * @param boolean  $absolute whether generate an absolute url
 *
 * @return string  the url
 */
function url($urlName, $params = [], $absolute = false)
{
    if ($absolute) {
        $absolute = Symfony\Component\Routing\Generator\UrlGeneratorInterface::ABSOLUTE_URL;
    } else {
        $absolute = Symfony\Component\Routing\Generator\UrlGeneratorInterface::ABSOLUTE_PATH;
    }

    global $kernel;
    return $kernel->getContainer()->get('router')->generate($urlName, $params, $absolute);
}

/**
 * Try to get the real IP of the client
 *
 * @return string the client ip
 */
function getUserRealIP()
{
    // REMOTE_ADDR: dirección ip del cliente
    // HTTP_X_FORWARDED_FOR: si no está vacío indica que se ha utilizado
    // un proxy. Al pasar por el proxy lo que hace este es poner su
    // dirección IP como REMOTE_ADDR y añadir la que estaba como
    // REMOTE_ADDR al final de esta cabecera.
    // En el caso de que la petición pase por varios proxys cada uno
    // repite la operación, por lo que tendremos una lista de direcciones
    // IP que partiendo del REMOTE_ADDR original irá indicando los proxys
    // por los que ha pasado.

    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])
        && $_SERVER['HTTP_X_FORWARDED_FOR'] != ''
    ) {
        $clientIp = ( !empty($_SERVER['REMOTE_ADDR']) ) ?
            $_SERVER['REMOTE_ADDR']
            :
            ( ( !empty($_ENV['REMOTE_ADDR']) ) ?
                $_ENV['REMOTE_ADDR']
                :
                "unknown" );

        // los proxys van añadiendo al final de esta cabecera
        // las direcciones ip que van "ocultando". Para localizar la ip real
        // del usuario se comienza a mirar por el principio hasta encontrar
        // una dirección ip que no sea del rango privado. En caso de no
        // encontrarse ninguna se toma como valor el REMOTE_ADDR

        $entries = preg_split('@[, ]@', $_SERVER['HTTP_X_FORWARDED_FOR']);


        foreach ($entries as $entry) {
            $entry = trim($entry);

            // http://www.faqs.org/rfcs/rfc1918.html
            if (preg_match("/^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/", $entry, $ipList)) {
                $privateIp = [
                    '/^0\./',
                    '/^127\.0\.0\.1/',
                    '/^192\.168\..*/',
                    '/^172\.((1[6-9])|(2[0-9])|(3[0-1]))\..*/',
                    '/^10\..*/'
                ];

                $foundIP = preg_replace($privateIp, $clientIp, $ipList[1]);

                if ($clientIp != $foundIP) {
                    $clientIp = $foundIP;
                    break;
                }
            }
        }
    } else {
        $clientIp = ( !empty($_SERVER['REMOTE_ADDR']) ) ?
            $_SERVER['REMOTE_ADDR']
            :
            ( ( !empty($_ENV['REMOTE_ADDR']) ) ?
                $_ENV['REMOTE_ADDR']
                :
                "unknown" );
    }

    return $clientIp;
}

function getService($serviceName)
{
    global $kernel;
    return $kernel->getContainer()->get($serviceName);
}

/**
 * Prepares HTML code to use it as html entity attribute
 *
 * @param string $string the string to clean
 *
 * @return string $string the cleaned string
 */
function html_attribute($string)
{
    return \Onm\StringUtils::htmlAttribute($string);
}

/**
 * undocumented function
 *
 * @return void
 * @author
 */
function dispatchEventWithParams($eventName, $params = [])
{
    if (php_sapi_name() == 'cli') {
        return;
    }

    $event           = new \Symfony\Component\EventDispatcher\GenericEvent();
    $eventDispatcher = getService('event_dispatcher');
    foreach ($params as $paramName => $paramValue) {
        $event->setArgument($paramName, $paramValue);
    }

    $eventDispatcher->dispatch($eventName, $event);
}
